\chapter{Language extension}

Rule basic structure
\begin{bnf*}
\bnfprod{rule}{
    \bnfpn{define} \bnfsp
    \bnfpn{from} \bnfsp
    \bnfpn{where} \bnfsp
    \bnfpn{consuming}
}
\end{bnf*}

Outline of each section
\begin{bnf*}
\bnfprod{define}{
    \bnfts{define} \bnfsp
    \bnfpn{capital identifier} \bnfsp
    \bnfts{(} \bnfsp
    \bnfpn{attributes} \bnfsp
    \bnfts{)}
}\\
\bnfprod{from}{
    \bnfts{from} \bnfsp
    \bnfpn{predicate body} \bnfsp
    \bnfpn{predicates}
}\\
\bnfprod{where}{
    \bnfts{where} \bnfsp
    \bnfpn{assignments} \bnfor
    \bnfes
}\\
\bnfprod{consuming}{
    \bnfts{consuming} \bnfsp
    \bnfpn{capital identifier} \bnfsp
    \bnfpn{capital identifiers} \bnfor
    \bnfes
}
\end{bnf*}

Details for define
\begin{bnf*}
\bnfprod{attributes}{
    \bnfpn{attribute} \bnfsp
    \bnfpn{attributes tail} \bnfor
    \bnfes
}\\
\bnfprod{attributes tail}{
    \bnfts{,} \bnfsp
    \bnfpn{attribute} \bnfsp
    \bnfpn{attributes tail} \bnfor
    \bnfes
}\\
\bnfprod{attribute}{
    \bnfpn{lower identifier} \bnfsp
    \bnfts{:} \bnfsp
    \bnfpn{attribute type}
}\\
\bnfprod{attribute type}{
    \bnfts{int} \bnfor
    \bnfts{float} \bnfor
    \bnfts{bool} \bnfor
    \bnfts{string}
}
\end{bnf*}

Details for from
\begin{bnf*}
\bnfprod{predicates}{
    \bnfts{and} \bnfsp
    \bnfpn{predicate} \bnfsp
    \bnfpn{predicates} \bnfor
    \bnfes
}\\
\bnfprod{predicate}{
    \bnfpn{event} \bnfor
    \bnfpn{aggregate} \bnfor
    \bnfpn{static}
}
\end{bnf*}

Details for where
\begin{bnf*}
\bnfprod{assignments}{
    \bnfpn{assignment} \bnfsp
    \bnfpn{assignments tail}
}\\
\bnfprod{assignments tail}{
    \bnfts{,} \bnfsp
    \bnfpn{assignment} \bnfsp
    \bnfpn{assignments tail} \bnfor
    \bnfes
}\\
\bnfprod{assignment}{
    \bnfpn{lower identifier} \bnfsp
    \bnfts{=} \bnfsp
    \bnfpn{expression}
}
\end{bnf*}

Details for predicate body
\begin{bnf*}
\bnfprod{predicate body}{
    \bnfpn{constrained tuple} \bnfsp
    \bnfpn{alias}
}\\
\bnfprod{constrained tuple}{
    \bnfpn{capital identifier} \bnfsp
    \bnfts{(} \bnfsp
    \bnfpn{constraints} \bnfsp
    \bnfts{)}
}\\
\bnfprod{constraints}{
    \bnfpn{expression} \bnfsp
    \bnfpn{constraints tail} \bnfor
    \bnfes
}\\
\bnfprod{constraints tail}{
    \bnfts{,} \bnfsp % Different from original papers!
    \bnfpn{expression} \bnfsp
    \bnfpn{constraints tail} \bnfor
    \bnfes
}\\
\bnfprod{alias}{
    \bnfts{as} \bnfsp
    \bnfpn{capital identifier} \bnfor
    \bnfes
}
\end{bnf*}

Details for event
\begin{bnf*}
\bnfprod{event}{
    \bnfpn{event selection} \bnfsp
    \bnfpn{predicate body} \bnfsp
    \bnfpn{timing}
}\\
\bnfprod{event selection}{
    \bnfts{each} \bnfor
    \bnfts{not} \bnfor
    \bnfts{first} \bnfor
    \bnfts{last}
}
\end{bnf*}

Details for aggregates
\begin{bnf*}
\bnfprod{aggregate}{
    \bnfpn{aggregate body} \bnfsp
    \bnfpn{aggregate constraint}
}\\
\bnfprod{aggregate body}{
    \bnfpn{aggregator} \bnfsp
    \bnfts{(} \bnfsp
    \bnfpn{constrained tuple} \bnfsp
    \bnfpn{timing} \bnfsp
    \bnfts{)}
}\\
\bnfprod{aggregator}{
    \bnfts{AVG} \bnfor
    \bnfts{SUM} \bnfor
    \bnfts{MAX} \bnfor
    \bnfts{MIN} \bnfor
    \bnfts{COUNT}
}\\
\bnfprod{aggregate constraint}{
    \bnfpn{binary operator} \bnfsp
    \bnfpn{expression}
}
\end{bnf*}

Details for static
\begin{bnf*}
\bnfprod{static}{
    \bnfpn{unordered static} \bnfor
    \bnfpn{ordered static}
}\\
\bnfprod{unordered static}{
    \bnfpn{unordered selection} \bnfsp
    \bnfpn{predicate body}
}\\
\bnfprod{unordered selection}{
    \bnfts{each} \bnfor
    \bnfts{any} \bnfor
    \bnfts{not}
}\\
\bnfprod{ordered static}{
    \bnfpn{ordered selection} \bnfsp
    \bnfpn{predicate body} \bnfsp
    \bnfpn{order}
}\\
\bnfprod{ordered selection}{
    \bnfts{first} \bnfor
    \bnfts{last}
}\\
\bnfprod{order}{
    \bnfts{ordered by} \bnfsp
    \bnfpn{lower identifier} \bnfsp
    \bnfpn{lower identifiers}
}
\end{bnf*}

Details for timing
\begin{bnf*}
\bnfprod{timing}{
    \bnfpn{within} \bnfor
    \bnfpn{between}
}\\
\bnfprod{within}{
    \bnfts{within} \bnfsp
    \bnfpn{time} \bnfsp
    \bnfts{from} \bnfsp
    \bnfpn{capital identifier}
}\\
\bnfprod{between}{
    \bnfts{between} \bnfsp
    \bnfpn{capital identifier} \bnfsp
    \bnfts{and} \bnfsp
    \bnfpn{capital identifier}
}\\
\bnfprod{time}{
    \bnfpn{float} \bnfsp
    \bnfpn{time unit} \bnfsp
}\\
\bnfprod{time unit}{
    \bnfts{d} \bnfor
    \bnfts{h} \bnfor
    \bnfts{min} \bnfor
    \bnfts{s} \bnfor
    \bnfts{ms} \bnfor
    \bnfts{us}
}
\end{bnf*}

Details for expressions and constraints
\begin{bnf*}
\bnfprod{expression}{
    \bnfpn{parenthesization} \bnfor
    \bnfpn{operation} \bnfor
	\bnfpn{atom}
}\\
\bnfprod{parenthesization}{
	\bnfts{(} \bnfsp
    \bnfpn{expression} \bnfsp
    \bnfts{)}
}\\
\bnfprod{operation}{
    \bnfpn{binary operation} \bnfor
    \bnfpn{unary operation}
}\\
\bnfprod{binary operation}{
    \bnfpn{expression} \bnfsp
    \bnfpn{binary operator} \bnfsp
    \bnfpn{expression}
}\\
\bnfprod{unary operation}{
    \bnfpn{unary operator} \bnfsp
    \bnfpn{expression}
}\\
\bnfprod{binary operator}{
    \bnftd{Common algebraic and comparison operators}
}\\
\bnfprod{unary operator}{
    \bnftd{Common unary operators}
}\\
\bnfprod{atom}{
    \bnfpn{identifier} \bnfor
    \bnfpn{parameter} \bnfor
    \bnfpn{immediate}
}\\
\bnfprod{identifier}{
	\bnfpn{qualifier} \bnfsp
    \bnfpn{lower identifier}
}\\
\bnfprod{qualifier}{
    \bnfpn{capital identifier} \bnfsp
    \bnfts{.} \bnfor
    \bnfes
}\\
\bnfprod{parameter}{
    \bnfts{\$} \bnfsp
    \bnfpn{lower identifier}
}\\
\bnfprod{immediate}{
    \bnftd{An immediate value, like a digit}
}
\end{bnf*}

Basic types
\begin{bnf*}
\bnfprod{capital identifier}{
    \bnftd{An identifier starting with an uppercase letter}
}\\
\bnfprod{lower identifier}{
    \bnftd{An identifier starting with a lowercase letter}
}\\
\bnfprod{capital identifiers}{
    \bnfts{,} \bnfsp
    \bnfpn{capital identifier} \bnfsp
    \bnfpn{capital identifiers} \bnfor
    \bnfes
}\\
\bnfprod{lower identifiers}{
    \bnfts{,} \bnfsp
    \bnfpn{lower identifier} \bnfsp
    \bnfpn{lower identifiers} \bnfor
    \bnfes
}\\
\bnfprod{float}{
    \bnftd{A floating point number}
}
\end{bnf*}

\begin{align*}
define &\quad CE(Att_1,\ ...\ Att_n) \\
from   &\quad SE(Att_x\ op\ Val_x)\ and \\
       &\quad each\ SD(Att_y\ op\ Val_y) \\
where  &\quad Att_1\ =\ f_1\ ...\ Att_n\ =\ f_n
\end{align*}

In the original paper have been defined the concept of $label$, to uniquely identify an event notification, the function $lab(Rule, Labels)$, to assign a label to a newly generated complex event, the trio predicate $Occurs(Type, Label)$ and the trio function $attVal(Label, Attribute)$.\\
Static data are quite similar to event notifications, so it's simple to extend the previous concepts to take them in to account.\\
We can extend labels to identify tuples too; the function $lab$ isn't changed and we can prove that the \emph{uniqueness of selection} remains valid; the predicate $Occurs$ is not relevant, since a tuple remains unchanged in every time instant; finally the function $attVal$ can be extended to return static tuple attributes.

%we can extend labels to identify them too. In this way they can concur in label generation for complex event
%To extend the language with static data, it is sufficient to say that every static tuple, event notification, is identified by a label too

\begin{align*}
&define\ CE\ from\ SE\ and\ each\ SD\ \triangleq\\
&Occurs(CE, lab(r, \{l_0, l_1\})\ \leftrightarrow\\
&(Occurs(SE, l_0)\ \wedge\ WithinP(Occurs(B, l_1),Time(l_0),x))
\end{align*}