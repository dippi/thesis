\chapter{Language extension}

% TODO rationale on languages needs and choices

\section{Tesla BNF Grammar}
% TODO add short intro

\subsection{Event type declaration}
% TODO add short description
\begin{bnf*}
\bnfprod{declaration}{
    \bnfpn{declare} \bnfsp
    \bnfpn{capital identifier} \bnfsp
    \bnfts{(} \bnfsp
    \bnfpn{attributes} \bnfsp
    \bnfts{)}
    \bnfpn{with id}
}\\
\bnfprod{declare}{
    \bnfts{declare} \bnfor
    \bnfts{declare fact}
}\\
\bnfprod{attributes}{
    \bnfpn{attribute} \bnfsp
    \bnfpn{attributes tail} \bnfor
    \bnfes
}\\
\bnfprod{attributes tail}{
    \bnfts{,} \bnfsp
    \bnfpn{attribute} \bnfsp
    \bnfpn{attributes tail} \bnfor
    \bnfes
}\\
\bnfprod{attribute}{
    \bnfpn{lower identifier} \bnfsp
    \bnfts{:} \bnfsp
    \bnfpn{attribute type}
}\\
\bnfprod{attribute type}{
    \bnfts{int} \bnfor
    \bnfts{float} \bnfor
    \bnfts{bool} \bnfor
    \bnfts{string}
}\\
\bnfprod{with id}{
    \bnfts{with id} \bnfsp
    \bnfpn{digits}
}
\end{bnf*}

\subsection{Event generation rule structure}
% TODO add short description
\begin{bnf*}
\bnfprod{rule}{
    \bnfpn{from} \bnfsp
    \bnfpn{where} \bnfsp
    \bnfpn{emit} \bnfsp
    \bnfpn{consuming}
}
\end{bnf*}

\subsection{Outline of each section}
% TODO add short description
\begin{bnf*}
\bnfprod{from}{
    \bnfts{from} \bnfsp
    \bnfpn{predicate body} \bnfsp
    \bnfpn{predicates}
}\\
\bnfprod{where}{
    \bnfts{where} \bnfsp
    \bnfpn{filters} \bnfor
    \bnfes
}\\
\bnfprod{emit}{
    \bnfts{emit} \bnfsp
    \bnfpn{capital identifier} \bnfsp
    \bnfts{(} \bnfsp
    \bnfpn{evaluations} \bnfsp
    \bnfts{)}
}\\
\bnfprod{consuming}{
    \bnfts{consuming} \bnfsp
    \bnfpn{capital identifier} \bnfsp
    \bnfpn{capital identifiers} \bnfor
    \bnfes
}
\end{bnf*}

\subsection{Details for from}
% TODO add short description
\begin{bnf*}
\bnfprod{predicates}{
    \bnfts{and} \bnfsp
    \bnfpn{predicate} \bnfsp
    \bnfpn{predicates} \bnfor
    \bnfes
}\\
\bnfprod{predicate}{
    \bnfpn{event} \bnfor
    \bnfpn{aggregate} \bnfor
    \bnfpn{static}
}
\end{bnf*}

\subsection{Details for where}
% TODO add short description
\begin{bnf*}
\bnfprod{filters}{
    \bnfpn{expression} \bnfsp
    \bnfpn{filters tail} \bnfor
    \bnfes
}\\
\bnfprod{filters tail}{
    \bnfts{and} \bnfsp
    \bnfpn{expression} \bnfsp
    \bnfpn{filters tail} \bnfor
    \bnfes
}
\end{bnf*}

\subsection{Details for emit}
% TODO add short description
\begin{bnf*}
\bnfprod{evaluations}{
    \bnfpn{evaluation} \bnfsp
    \bnfpn{evaluations tail} \bnfor
    \bnfes
}\\
\bnfprod{evaluations tail}{
    \bnfts{,} \bnfsp
    \bnfpn{evaluation} \bnfsp
    \bnfpn{evaluations tail} \bnfor
    \bnfes
}\\
\bnfprod{evaluation}{
    \bnfpn{lower identifier} \bnfsp
    \bnfts{=} \bnfsp
    \bnfpn{expression}
}
\end{bnf*}

\subsection{Details for predicate body}
% TODO add short description
\begin{bnf*}
\bnfprod{predicate body}{
	% TODO forbid param assignment in combination with 'not' 
    \bnfpn{capital identifier} \bnfsp
    \bnfts{[} \bnfsp
    \bnfpn{assignments} \bnfsp
    \bnfts{]} \bnfsp
    \bnfts{(} \bnfsp
    \bnfpn{constraints} \bnfsp
    \bnfts{)} \bnfsp
    \bnfpn{alias}
}\\
\bnfprod{assignments}{
    \bnfpn{assignment} \bnfsp
    \bnfpn{assignments tail} \bnfor
    \bnfes
}\\
\bnfprod{assignments tail}{
    \bnfts{,} \bnfsp
    \bnfpn{assignment} \bnfsp
    \bnfpn{assignments tail} \bnfor
    \bnfes
}\\
\bnfprod{assignment}{
    \bnfpn{parameter} \bnfsp
    \bnfts{=} \bnfsp
    \bnfpn{expression}
}\\
\bnfprod{constraints}{
    \bnfpn{expression} \bnfsp
    \bnfpn{constraints tail} \bnfor
    \bnfes
}\\
\bnfprod{constraints tail}{
    \bnfts{,} \bnfsp
    \bnfpn{expression} \bnfsp
    \bnfpn{constraints tail} \bnfor
    \bnfes
}\\
\bnfprod{alias}{
    \bnfts{as} \bnfsp
    \bnfpn{capital identifier} \bnfor
    \bnfes
}
\end{bnf*}

\subsection{Details for event}
% TODO add short description
\begin{bnf*}
\bnfprod{event}{
    \bnfpn{event selection} \bnfsp
    \bnfpn{predicate body} \bnfsp
    \bnfpn{timing}
}\\
\bnfprod{event selection}{
    \bnfts{each} \bnfor
    \bnfts{not} \bnfor % TODO maybe move in aggregates
    \bnfts{first} \bnfor
    \bnfts{last}
}
\end{bnf*}

\subsection{Details for aggregates}
% TODO add short description
\begin{bnf*}
\bnfprod{aggregate}{
	\bnfpn{aggregate assignment} \bnfsp
    \bnfpn{aggregate body}
}\\
\bnfprod{aggregate assignment}{
    \bnfpn{parameter} \bnfsp
    \bnfts{=} \bnfor
    \bnfes
}\\
\bnfprod{aggregate body}{
    \bnfpn{aggregator} \bnfsp
    \bnfts{(} \bnfsp
    \bnfpn{constrained tuple} \bnfsp
    \bnfpn{timing} \bnfsp
    \bnfts{)}
}\\
\bnfprod{aggregator}{
    \bnfts{AVG} \bnfor
    \bnfts{SUM} \bnfor
    \bnfts{MAX} \bnfor
    \bnfts{MIN} \bnfor
    \bnfts{COUNT}
    % TODO maybe add EXISTS/ANY and NOT
}\\
\bnfprod{constrained tuple}{
	\bnfpn{capital identifier} \bnfsp
    \bnfts{(} \bnfsp
    \bnfpn{constraints} \bnfsp
    \bnfts{)} \bnfsp
    \bnfpn{attribute selection}
}\\
\bnfprod{attribute selection}{
    \bnfts{.} \bnfsp
    \bnfpn{lower identifier} \bnfor
    \bnfes
}
\end{bnf*}

\subsection{Details for static}
% TODO add short description
\begin{bnf*}
\bnfprod{static}{
    \bnfpn{unordered static} \bnfor
    \bnfpn{ordered static}
}\\
\bnfprod{unordered static}{
    \bnfpn{unordered selection} \bnfsp
    \bnfpn{predicate body}
}\\
\bnfprod{unordered selection}{
    \bnfts{each} \bnfor
    \bnfts{not} % TODO maybe move in aggregates
}\\
\bnfprod{ordered static}{
    \bnfpn{ordered selection} \bnfsp
    \bnfpn{predicate body} \bnfsp
    \bnfpn{ordered by}
}\\
\bnfprod{ordered selection}{
    \bnfts{first} \bnfor
    \bnfts{last}
}\\
\bnfprod{ordered by}{
    \bnfts{ordered by} \bnfsp
    \bnfpn{ordering} \bnfsp
    \bnfpn{orderings}
}\\
\bnfprod{ordering}{
    \bnfpn{lower identifier} \bnfsp
    \bnfpn{order}
}\\
\bnfprod{orderings}{
    \bnfts{,} \bnfsp
    \bnfpn{ordering} \bnfsp
    \bnfpn{orderings}
}\\
\bnfprod{order}{
    \bnfts{asc} \bnfor
    \bnfts{desc}
}
\end{bnf*}

\subsection{Details for timing}
% TODO add short description
\begin{bnf*}
\bnfprod{timing}{
    \bnfpn{within} \bnfor
    \bnfpn{between}
}\\
\bnfprod{within}{
    \bnfts{within} \bnfsp
    \bnfpn{time} \bnfsp
    \bnfts{from} \bnfsp
    \bnfpn{capital identifier}
}\\
\bnfprod{between}{
    \bnfts{between} \bnfsp
    \bnfpn{capital identifier} \bnfsp
    \bnfts{and} \bnfsp
    \bnfpn{capital identifier}
}\\
\bnfprod{time}{
    \bnfpn{float} \bnfsp
    \bnfpn{time unit} \bnfsp
}\\
\bnfprod{time unit}{
    \bnfts{d} \bnfor
    \bnfts{h} \bnfor
    \bnfts{min} \bnfor
    \bnfts{s} \bnfor
    \bnfts{ms} \bnfor
    \bnfts{us}
}
\end{bnf*}

\subsection{Details for expressions and constraints}
% TODO add short description
\begin{bnf*}
\bnfprod{expression}{
    \bnfpn{parenthesization} \bnfor
    \bnfpn{operation} \bnfor
	\bnfpn{atom}
}\\
\bnfprod{parenthesization}{
	\bnfts{(} \bnfsp
    \bnfpn{expression} \bnfsp
    \bnfts{)}
}\\
\bnfprod{operation}{
    \bnfpn{binary operation} \bnfor
    \bnfpn{unary operation}
}\\
\bnfprod{binary operation}{
    \bnfpn{expression} \bnfsp
    \bnfpn{binary operator} \bnfsp
    \bnfpn{expression}
}\\
\bnfprod{unary operation}{
    \bnfpn{unary operator} \bnfsp
    \bnfpn{expression}
}\\
\bnfprod{binary operator}{
    \bnftd{Common algebraic and comparison operators}
}\\
\bnfprod{unary operator}{
    \bnftd{Common unary operators}
}\\
\bnfprod{atom}{
    \bnfpn{identifier} \bnfor
    \bnfpn{parameter} \bnfor
    \bnfpn{immediate}
}\\
% TODO differentiate between different contexts
\bnfprod{identifier}{
	\bnfpn{qualifier} \bnfsp
    \bnfpn{lower identifier}
}\\
\bnfprod{qualifier}{
    \bnfpn{capital identifier} \bnfsp
    \bnfts{.} \bnfor
    \bnfes
}
\end{bnf*}

\subsection{Basic types}
% TODO add short description
\begin{bnf*}
\bnfprod{capital identifier}{
    \bnftd{An identifier starting with an uppercase letter}
}\\
\bnfprod{lower identifier}{
    \bnftd{An identifier starting with a lowercase letter}
}\\
\bnfprod{parameter}{
    \bnfts{\$} \bnfsp
    \bnfpn{lower identifier}
}\\
\bnfprod{capital identifiers}{
    \bnfts{,} \bnfsp
    \bnfpn{capital identifier} \bnfsp
    \bnfpn{capital identifiers} \bnfor
    \bnfes
}\\
\bnfprod{lower identifiers}{
    \bnfts{,} \bnfsp
    \bnfpn{lower identifier} \bnfsp
    \bnfpn{lower identifiers} \bnfor
    \bnfes
}\\
\bnfprod{immediate}{
    \bnftd{An immediate value, like a digit}
}\\
\bnfprod{float}{
    \bnftd{A floating point number}
}
\end{bnf*}

\newpage
% \begin{align*}
% define &\quad CE(Att_1,\ ...\ Att_n) \\
% from   &\quad SE(Att_x\ op\ Val_x)\ and \\
%        &\quad each\ SD(Att_y\ op\ Val_y) \\
% where  &\quad Att_1\ =\ f_1\ ...\ Att_n\ =\ f_n
% \end{align*}

\section{Semantic of rules}

\subsection{Extension of logical concepts}
The original paper defines the concept of $label$, to uniquely identify an event notification, the function $lab(Rule, Labels)$, to assign a label to a newly generated complex event, the trio predicate $Occurs(Type, Label)$ and the trio function $attVal(Label, Attribute)$.\\
Static data are quite similar to event notifications, so it's simple to extend the previous concepts to take them in to account.

\subsubsection{Labels and uniqueness of selection}
We can extend the meaning of labels to identify data too, so that a label can be associated to an event notification or to a tuple and only one of them. In this way the function $lab$ isn't changed, making no distinction between what labels are associated to, and the \emph{uniqueness of selection} remains valid, because a trigger event is still required.

\subsubsection{Definition of predicate $ThereIs$}
The predicate $Occurs$ is not applicable, since a tuple remains unchanged in every time instant, so we define the predicate $ThereIs(Type, Label)$ for the similar purpose of stating that a label is associated to a tuple of a given type.

\begin{align*}
  &Alw(\forall s \in S, \forall e \in E, \forall l \in L\\
  &(ThereIs(s, l) \rightarrow Alw(\neg Occurs(e, l))))
\end{align*}

\begin{align*}
  &Alw(\forall s_1,s_2 \in S, \forall l \in L\\
  &((ThereIs(s_1, l) \wedge ThereIs(s_2, l)) \rightarrow s_1=s_2))
\end{align*}

\begin{align*}
  &Alw(\forall s \in S, \forall l \in L\\
  &(ThereIs(s, l) \rightarrow Alw(ThereIs(s, l)))
\end{align*}

Where $L$ is the set of all labels, $E$ the set of all event types and $S$ the set of all static data types.\\
The first formula states that a label cannot be associated with both a tuple and an event. The second states that cannot be two tuple having the same label and different data type. The third states that if a tuple exist at a certain point in time it exists along the whole time line.

\subsubsection{Extension of predicate $attVal$}
Similarly the function $attVal$ can be extended to return attributes of static tuples.

\subsection{Event composition}
% TODO add a short description
\begin{align*}% Example of each
&from\ SE\ and\ each\ SD\ emit\ CE\ \triangleq\\
&Occurs(CE, lab(r, \{l_0, l_1\})\ \leftrightarrow\\
&(Occurs(SE, l_0)\ \wedge\ ThereIs(SD, l_1))
\end{align*}

\begin{align*}% Example of not
&from\ SE\ and\ not\ SD\ emit\ CE\ \triangleq\\
&Occurs(CE, lab(r, \{l_0\})\ \leftrightarrow\\
&(Occurs(SE, l_0)\ \wedge\ \not \exists l_1 ThereIs(SD, l_1))
\end{align*}

\begin{align*}% Example of first
&from\ SE\ and\ first\ SD\ order\ by\ Att_1\ emit\ CE\ \triangleq\\
&Occurs(CE, lab(r, \{l_0, l_1\})\ \leftrightarrow\ (Occurs(SE, l_0)\ \wedge\ ThereIs(SD, l_1)\\
&\wedge\ (\not \exists l_2\ (ThereIs(SD, l_2)\ \wedge\ (attVal(l_1, Att_1)\ <\ attVal(l_2, Att_1)))))
\end{align*}

\begin{align*}% Example of last
&from\ SE\ and\ last\ SD\ order\ by\ Att_1\ emit\ CE\ \triangleq\\
&Occurs(CE, lab(r, \{l_0, l_1\})\ \leftrightarrow\ (Occurs(SE, l_0)\ \wedge\ ThereIs(SD, l_1)\\
&\wedge\ (\not \exists l_2\ (ThereIs(SD, l_2)\ \wedge\ (attVal(l_1, Att_1)\ >\ attVal(l_2, Att_1)))))
\end{align*}

\begin{align*}% Example of attribute constraint
&from\ SE\ and\ each\ SD(Att_1\ op \ Val_1)\ emit\ CE\ \triangleq\\
&Occurs(CE, lab(r, \{l_0, l_1\})\ \leftrightarrow\ (Occurs(SE, l_0)\\
&\wedge\ ThereIs(SD, l_1)\ \wedge\ (attVal(l_1, Att_1)\ op\ Val_1))
\end{align*}

\begin{align*}% Example of aggregates
&from\ SE\ and\ AGGR(SD.Att_1)\ op\ Y\ emit\ CE\ \triangleq\\
&Occurs(CE, lab(r, \{l_0\})\ \leftrightarrow\ (Occurs(SE, l_0)\\
&\wedge\ \forall Set\ (\forall x, \forall l \in L
(x \in Set\ \leftrightarrow\ (ThereIs(SD, l)\\
&\wedge\ x\ =\ attVal(l, Att_1))))\ \wedge\ AGGR(Set)\ op\ Y)
\end{align*}

\begin{align*}% Example of parameters
&from\ SE(Att_i\ = \ \$Par)\ and\ each\ SD(Att_j\ = \ \$Par)\ emit\ CE\ \triangleq\\
&Occurs(CE, lab(r, \{l_0, l_1\})\ \leftrightarrow\ (Occurs(SE, l_0)\\
&\wedge\ ThereIs(SD, l_1)\ \wedge\ (attVal(l_0, Att_i)\ =\ attVal(l_1, Att_j)))
\end{align*}

% TODO maybe example of parametrization and aggregates?
